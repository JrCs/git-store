#!/bin/bash
#
# Created by Yves Blusseau
#
# This script is use to store/retrieve files store on a remote git repository
#
# Copyright (C) 2014-2015 Yves Blusseau
# Licensed under the Apace License 2.0
# http://www.apache.org/licenses/LICENSE-2.0.html
#

declare -r VERSION="0.7"

declare -r HEADER_STORE=$(cat <<EOF
#
# THIS FILE IS AUTOGENERATED! DO NOT MODIFY IT!
#
# Hash                                  | File       | Size
EOF
)

declare -r self="${0##*/}"
declare -r REFS_STORE="refs/store"
declare -r EMPTY_BLOB_HASH='e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'

# Helper library for git-store
#
# Copyright (C) 2014 Yves Blusseau
#
version_sort ()
{
    case $version_sort_sort_has_v in
        yes)
             LC_ALL=C sort -V;;
        no)
            LC_ALL=C sort -n;;
        *)
           if sort -V </dev/null > /dev/null 2>&1; then
               version_sort_sort_has_v=yes
               LC_ALL=C sort -V
           else
               version_sort_sort_has_v=no
               LC_ALL=C sort -n
           fi;;
    esac
}

version_test_numeric ()
{
    version_test_numeric_a="$1"
    version_test_numeric_cmp="$2"
    version_test_numeric_b="$3"
    if [ "$version_test_numeric_a" = "$version_test_numeric_b" ] ; then
        case "$version_test_numeric_cmp" in
            ge|eq|le) return 0 ;;
            gt|lt) return 1 ;;
        esac
    fi
    if [ "$version_test_numeric_cmp" = "lt" ] ; then
        version_test_numeric_c="$version_test_numeric_a"
        version_test_numeric_a="$version_test_numeric_b"
        version_test_numeric_b="$version_test_numeric_c"
    fi
    if (echo "$version_test_numeric_a" ; echo "$version_test_numeric_b") | version_sort | head -n 1 | grep -qx "$version_test_numeric_b" ; then
        return 0
    else
        return 1
    fi
}

version_test_gt ()
{
    version_test_gt_a="`echo "$1" | sed -e "s/[^-]*-//"`"
    version_test_gt_b="`echo "$2" | sed -e "s/[^-]*-//"`"
    version_test_gt_cmp=gt
    if [ "x$version_test_gt_b" = "x" ] ; then
        return 0
    fi
    case "$version_test_gt_a:$version_test_gt_b" in
        *.old:*.old) ;;
        *.old:*) version_test_gt_a="`echo -n "$version_test_gt_a" | sed -e 's/\.old$//'`" ; version_test_gt_cmp=gt ;;
        *:*.old) version_test_gt_b="`echo -n "$version_test_gt_b" | sed -e 's/\.old$//'`" ; version_test_gt_cmp=ge ;;
    esac
    version_test_numeric "$version_test_gt_a" "$version_test_gt_cmp" "$version_test_gt_b"
    return "$?"
}

print_option_help () {
    if test x${print_option_help_wc:-} = x; then
        if wc -L  </dev/null > /dev/null 2>&1; then
            print_option_help_wc=-L
        elif wc -m  </dev/null > /dev/null 2>&1; then
            print_option_help_wc=-m
        else
            print_option_help_wc=-b
        fi
    fi
    if test x${_have_fmt:-} = x; then
        if fmt -w 40  </dev/null > /dev/null 2>&1; then
            _have_fmt=y;
        else
            _have_fmt=n;
        fi
    fi
    print_option_help_lead="  $1"
    print_option_help_lspace="$(echo "$print_option_help_lead" | wc $print_option_help_wc)"
    print_option_help_fill="$((26 - print_option_help_lspace))"
    printf "%s" "$print_option_help_lead"
    if test $print_option_help_fill -le 0; then
        print_option_help_nl=y
        echo
    else
        print_option_help_i=0;
        while test $print_option_help_i -lt $print_option_help_fill; do
            printf " "
            print_option_help_i=$((print_option_help_i+1))
        done
        print_option_help_nl=n
    fi
    if test x$_have_fmt = xy; then
        print_option_help_split="$(echo "${2:-}" | fmt -w 50)"
    else
        print_option_help_split="${2:-}"
    fi
    if test x$print_option_help_nl = xy; then
        echo "$print_option_help_split" | awk \
 '{ print "                          " $0; }'
    else
        echo "$print_option_help_split" | awk 'BEGIN   { n = 0 }
    { if (n == 1) print "                          " $0; else print $0; n = 1 ; }'
    fi
}


# Convert numeric size to human
declare -a _unit=( $((2**30)) $((2**20)) $((2**10)) )
declare -a _unit_string=( 'G' 'M' 'K' )

numeric_to_human() {
    local value=${1?missing argument}
    local idx=0
    local u
    if [[ "$value" -lt 1024 ]]; then
        echo "${value}"
        return
    fi
    for u in "${_unit[@]}"; do
        if [[ $value -ge $u ]]; then
            local result=$(echo "scale=0; $value / $u" | bc -l)
            echo "$result${_unit_string[$idx]}"
            return
        fi
        (( idx++ ))
    done
}

# Convert human size to numeric
human_to_numeric() {
    local value=${1?missing argument}
    local i
    for i in "g G m M k K"; do
        value=${value//[gG]/*1024m}
        value=${value//[mM]/*1024k}
        value=${value//[kK]/*1024}
    done
    [[ ${value} == *\** ]] && echo $((value)) || return 1
}


# Return on absolute path from a relative or absolute path
# Remove . and .. in the path
abspath() {
    local thePath="${1?missing path argument}"
    local fromPath="${2:-$PWD}"
    if [[ ! "$1" =~ ^/ ]]; then
        thePath="$fromPath/$thePath"
    fi
    local IFS=/
    local i
    read -a parr <<< "$thePath"
    declare -a outp
    for i in "${parr[@]}";do
        case "$i" in
            ''|.) continue ;;
            ..)
                local len=${#outp[@]}
                if ((len==0));then
                    continue
                else
                    unset outp[$((len-1))]
                fi
                ;;
            *)
               outp+=("$i")
               ;;
        esac
    done
    echo /"${outp[*]}"
}

relpath() {
    local path="${1?missing path argument}"
    local base="${2?missing base argument}"
    perl -e 'use File::Spec; print File::Spec->abs2rel(@ARGV) . "\n"' "$path" "$base"
}


# Colors

say_color() {
    local fmt="%s"
    case "$1" in
        red)
            fmt='\e[0;31m%b\e[0m';; # red
        blue)
            fmt='\e[0;34m%b\e[0m';; # blue
        yellow)
            fmt='\e[0;33m%b\e[0m';; # yellow
        green)
            fmt='\e[0;32m%b\e[0m';; # green
        cyan)
            fmt='\e[0;36m%b\e[0m';; # cyan
        error|bred)
            fmt='\e[1;31m%b\e[0m';; # bold red
        skip|bblue)
            fmt='\e[1;34m%b\e[0m';; # bold blue
        warn|byellow)
            fmt='\e[1;33m%b\e[0m';; # bold yellow
        pass|bgreen)
            fmt='\e[1;32m%b\e[0m';; # bold green
        info|bcyan)
            fmt='\e[1;36m%b\e[0m';; # bold cyan
    esac
    shift
    printf "$fmt" "$*"
}

say() {
    say_color info "$*"
}

error() {
    say_color error "Error: $*" >&2
}

die() {
    error "$*"
    exit 1
}

function echob() {
    echo $(tput bold)"$1"$(tput sgr0)
}


# Main functions for git-store
#

# Return the full path from pwd if $path is relative
# else it return $path
_get_abspath_from_pwd() {
    local path="${1:?missing argument}"
    echo $(abspath "$path" "$PWD")
}

# Return the full path from $root_dir if $path is relative
# else it return $path
_get_abspath_from_rootdir() {
    local path="${1:?missing argument}"
    echo $(abspath "$path" "$ROOT_DIR")
}

_get_relative_store_path_from_pwd() {
    local file="${1:?missing argument}"
    local full_path
    if [[ "$file" =~ ^/ ]]; then
        # Already absolute
        full_path="$file"
    else
        #It's relative
        full_path=$(_get_abspath_from_rootdir "$file")
    fi
    local relative_to_pwd=$(relpath "$full_path" "$PWD")
    echo "$relative_to_pwd"
}

_get_relative_store_path_from_rootdir() {
    local file="${1:?missing argument}"
    local full_path
    if [[ "$file" =~ ^/ ]]; then
        # Already absolute
        full_path="$file"
    else
        #It's relative
        full_path="$(_get_abspath_from_rootdir "$file")"
    fi
    echo "${full_path/$ROOT_DIR\//}"
}

_escape_ereg() {
    sed 's/[]\.|$(){}?+*^]/\\&/g' <<< "$@"
}

git_store() {
    git --git-dir="$STORE_GIT_DIR" "$@"
}

_define_remote_store_name() {
    [[ -n "${REMOTE_STORE_URL:-}" ]] && return 0
    # By default try to use the same remote that is used for the current branch
    REMOTE_STORE_URL=$(git ls-remote --get-url)
    [[ -z "$REMOTE_STORE_URL" ]] && die "The current branch has no upstream defined !\n"
    # Try to get the remote name
    REMOTE_STORE=$(git remote -v | awk -vURL=$REMOTE_STORE_URL '{ if ($2 == URL && $3 == "(fetch)" ) { print $1 }}' | head -n 1)
    [[ -z "$REMOTE_STORE" ]] && die "The current branch has no upstream defined !\n"
}

_update_store_file() {
    local file="${1:?missing argument}"
    local hash=${2:-}
    if [[ -f "$STORE_LOCAL_INDEX" ]]; then
        local ereg="$(_escape_ereg "$file")"
        egrep -v "^#|[A-Fa-f0-9]{40}[|]${ereg}[|]" "$STORE_LOCAL_INDEX" > "$STORE_LOCAL_INDEX"~
    fi
    if [[ -n "$hash" ]]; then
        local size=$(git_store cat-file -s $hash) || exit $?
        echo "$hash|$file|$size" >> "$STORE_LOCAL_INDEX"~
    fi
    echo "$HEADER_STORE" > "$STORE_LOCAL_INDEX"
    cat "$STORE_LOCAL_INDEX"~ | sort -u -t'|' -k2 >> "$STORE_LOCAL_INDEX"
    rm -f "${STORE_LOCAL_INDEX}"~
}

_get_hash_from_store() {
    search_file="${1:?missing argument}"
    if [[ -f "${STORE_LOCAL_INDEX}" ]]; then
        local relfile=$(_get_relative_store_path_from_rootdir "$search_file")
        local ereg="$(_escape_ereg "$relfile")"
        sed -nr "s|([A-Fa-f0-9]{40})[|]$ereg[|].*|\1|p" "${STORE_LOCAL_INDEX}"
    fi
}

_get_hash_from_store_index() {
    search_file="${1:?missing argument}"
    if [[ -f "${STORE_INDEX}" ]]; then
        local relfile=$(_get_relative_store_path_from_rootdir "$search_file")
        local ereg="$(_escape_ereg "$relfile")"
        sed -nr "s|^[AD][|]$ereg[|]([A-Fa-f0-9]{40}).*|\1|p" "${STORE_INDEX}"
    fi
}

_get_action_from_store_index() {
    search_file=${1:?missing argument}
    if [[ -f "${STORE_INDEX}" ]]; then
        local relfile=$(_get_relative_store_path_from_rootdir "$search_file")
        local ereg="$(_escape_ereg "$relfile")"
        sed -nr "s|^([AD])[|]$ereg[|].*|\1|p" "${STORE_INDEX}"
    fi
}

store_add() {
    for file in "$@"; do
        if [[ ! -e "$file" ]]; then
            error "the file '$file' doesn't exist !\n" >&2
            continue
        fi
        if [[ -d "$file" ]]; then
            error "can't add '$file' it's a directory\n" >&2
            continue
        fi

        local full=$(_get_abspath_from_pwd "$file")

        if [[ -L "$full" ]]; then
            # Short circuit if file is already in store
            [[ $(readlink -f "$full") == "$STORE_OBJECTS_DIR"/* ]] && return 0
            echo "error: can't add '$file' it's a link" >&2
            continue
        fi
        # Store the file
        local hash=$(git_store hash-object -t blob -w "$full") || exit $?
        git_store update-ref "$REFS_STORE/$hash" $hash || exit $?
        local object="$STORE_OBJECTS_DIR/$hash"
        mv -f "$full" "$object" || exit 1
        chmod a-w "$object" || exit 1
        ln -sf $(relpath "$STORE_OBJECTS_DIR/$hash" "${full%/*}") "$full" || exit 1
        # Add to the index file
        _store_store "$hash" "$full"
        # Add the link
        git add "$file"
    done
}

store_remove() {
    for file in "$@"; do
        local full=$(_get_abspath_from_pwd "$file")
        local hash=""
        if [[ -f "$full" ]]; then
            # Store the file in case so we can restore it
            hash=$(git_store hash-object -t blob -w "$full") || exit $?
            git rm -f "$full"
        fi
        local relfile=$(_get_relative_store_path_from_rootdir "$full")
        if [[ -f "$STORE_INDEX" ]]; then
            local ereg="$(_escape_ereg "$relfile")"
            egrep -v "^[AD][|]${ereg}[|]" "$STORE_INDEX" > "$STORE_INDEX"~
        fi
        echo "D|$relfile|$hash" >> "$STORE_INDEX"~
        mv "$STORE_INDEX"~ "$STORE_INDEX"
    done
}

_store_store() {
    local hash=${1:?missing argument hash}
    local file=${2:?missing argument file}
    local relfile=$(_get_relative_store_path_from_rootdir "$file")
    _update_store_file "$relfile" "$hash" || exit $?
}

_store_remove_store() {
    local file=${1:?missing argument file}
    local relfile=$(_get_relative_store_path_from_rootdir "$file")
    _update_store_file "$relfile" || exit $?
}

_fetch_remote_ref() {
    local ref=${1:?missing argument ref}
    _define_remote_store_name
    # First check if the repository is correctly initialized and ref exists
    git_store ls-remote --exit-code $REMOTE_STORE_URL $REFS_STORE/$ref >/dev/null
    local exit_code=$?
    case "$exit_code" in
        0) ;;
        2) error "The reference doesn't exists on $REMOTE_STORE!\n"; return $exit_code ;;
        *) die "Can't get remote reference !\nIs the $REMOTE_STORE repository initialized correctly ?\n"
    esac
    git_store fetch -q $REMOTE_STORE_URL $REFS_STORE/$ref:$REFS_STORE/$ref 2>&1
}

_fetch_remote_ref_all_files() {
    local ref='all_files'
    _define_remote_store_name
    # First check if the repository is correctly initialized and ref exists
    git_store ls-remote --exit-code $REMOTE_STORE_URL $REFS_STORE/$ref >/dev/null
    local exit_code=$?
    case "$exit_code" in
        0) git_store fetch -q $REMOTE_STORE_URL $REFS_STORE/$ref:$REFS_STORE/$ref 2>&1
           ;;
        2) # If the all_files reference doesn't exists on the remote create an empy one
           local empty_blob_hash=$(git_store hash-object -w /dev/null)
           git_store update-ref $REFS_STORE/$ref $empty_blob_hash
           ;;
        *) die "Can't get remote reference !\nIs the $REMOTE_STORE repository initialized correctly ?\n"
           ;;
    esac
    return $?
}

store_commit() {
    if [[ -f "$STORE_INDEX" ]]; then
        while IFS='|' read action file hash; do
            case "$action" in
                A) _store_store $hash "$file";;
                D) _store_remove_store "$file";;
            esac
        done < <(egrep -v '^#' "$STORE_INDEX")
    fi
    rm -f "$STORE_INDEX"

    # Add new local references
    while IFS='|' read hash file; do
        git_store cat-file -e $hash
        [[ $? -ne 0 ]] && continue
        git_store update-ref "$REFS_STORE/$hash" $hash || exit $?
    done < <(egrep -v '^#' "$STORE_LOCAL_INDEX")

    # remove old local references
    while read hash ref; do
        # check if the ref exists in the store
        if [[ $(egrep -c "^$hash[|]" "$STORE_LOCAL_INDEX") -eq 0 ]]; then
            git_store update-ref -d "$ref" || exit $?
        fi
    done < <(git_store for-each-ref --format='%(objectname) %(refname)' | egrep "\s$REFS_STORE/[A-Fa-f0-9]{40}")
}

_do_checkout() {
    local full="${1:?missing argument file path}"
    if [[ ! "$full" =~ ^/ ]]; then
        echo "[_do_checkout] error: file path must be absolute !" >&2
        exit 1
    fi

    local object_file=$(readlink "$full")
    [[ "$object_file" != *"$STORE_OBJECT_DIR_FROM_ROOT"/* ]] && return 0
    local hash="${object_file##*/}" # get hash from object name
    object_file="$STORE_OBJECTS_DIR/$hash" # fix bad link
    if [[ ! -f "$object_file" ]]; then
        # Check if the hash exists
        git_store cat-file -e $hash
        local hash_exist=$([[ $? -eq 0 ]] && echo 1 || echo 0)
        if [[ "$hash_exist" -eq 0 ]]; then
            # Try to download from remote
            _define_remote_store_name
            local relfile=$(_get_relative_store_path_from_rootdir "$full")
            printf "Downloading %s from %s...\n" "$(say_color cyan $relfile)" "$(say_color green $REMOTE_STORE)"
            _fetch_remote_ref "$hash" || return $?
        fi
        git_store update-ref "$REFS_STORE/$hash" $hash
        git_store show $hash -- > "$object_file" || exit 1
    fi
    chmod a-w "$object_file"
    if [[ ! -e "$full" ]]; then # fix bad link
        local dirname_file="${full%/*}"
        local object_file_relative_to_file=$(relpath "$object_file" "$dirname_file")
        ln -sf "$object_file_relative_to_file" "$full" || exit $?
    fi
}

store_checkout() {
    local files_to_get=()
    for arg in "${@}"; do
        [[ "$arg" == ':/' ]] && arg="$ROOT_DIR"
        if [[ -d "$arg" ]]; then
            while read -r file; do
                if [[ -L "$file" ]]; then
                    local object_file=$(readlink "$file")
                    if [[ "$object_file" == *"$STORE_OBJECT_DIR_FROM_ROOT"/* ]]; then
                        files_to_get+=( "$file" )
                    fi
                fi
            done < <(git ls-files -c -o "$arg")
        else
            files_to_get+=( "$arg" )
        fi
    done

    if [[ -n "${files_to_get[@]:-}" ]]; then
        for file in "${files_to_get[@]}"; do
            local full=$(_get_abspath_from_pwd "$file")
            _do_checkout "$full"
        done
    fi
}

store_list() {
    local cmd
    local tmp1
    if [[ "$OPT_REMOTE" -eq 1 ]]; then
        _fetch_remote_ref_all_files || exit $?
        cmd=("git_store" "show" "$REFS_STORE/all_files")
    else
        tmp1=$(mktemp)
        while read -r link_hash file; do
            local object_file=$(git cat-file -p $link_hash)
            if [[ "$object_file" == *"$STORE_OBJECT_DIR_FROM_ROOT"/* ]]; then
                local hash="${object_file##*/}" # get hash from object name
                local size=$(git_store cat-file -s $hash 2>/dev/null)
                if [[ -n "$size" ]]; then
                    local timestamp=""
                    [[ -f "$STORE_OBJECTS_DIR/$hash" ]] && timestamp=$(stat --format='%Y' "$STORE_OBJECTS_DIR/$hash")
                    echo "$hash|$file|$size|$timestamp" >> "$tmp1"
                fi
            fi
        done < <(git ls-files -s ":/"  | awk '/^120000/ { $1=$3=""; printf "%s\n",substr($0,2)}' )
        cmd=("cat" "$tmp1")
    fi
    local now=$(date '+%s')
    local sort_opt=( -k 2 ) # sort by filename
    [[ "$OPT_S" -ne 0 ]] && sort_opt=( -n -k 3 ) # sort by size
    [[ "$OPT_T" -ne 0 ]] && sort_opt=( -n -k 4 ) # sort by date
    [[ "$OPT_R" -ne 0 ]] && sort_opt+=( -r ) # reverse sorting
    local tmp=$(mktemp)
    local total=0
    while IFS='|' read hash file size timestamp; do
        local date='     -     '
        if [[ -n "$timestamp" ]]; then
            local fmt='%b %d %R'
            # timestamp > 1 year
            [[ $(($now - $timestamp)) -gt 31536000 ]] && fmt="%b %d  %Y"
            date=$(date -d @$timestamp "+$fmt")
        fi
        total=$(( $total + $size ))
        printf "%s|%s|%s\n" $(numeric_to_human "$size") "$date" "$(_get_relative_store_path_from_pwd "$file")"
    done < <(${cmd[*]} | sort -t '|' ${sort_opt[@]}) >"$tmp"
    [[ -n "${tmp1:-}" ]] && rm -f "$tmp1"
    column -s '|' -t "$tmp"
    rm -f "$tmp"
    printf "Total: %s\n" $(numeric_to_human $total)
}

_status_index_added() {
    local file=${1:?missing argument}
    local hash=${2:?missing argument}
    local text
    local old_hash=$(_get_hash_from_store "$file")

    if [[ -z "$old_hash" ]]; then
        text=$(_status_added "$file")
    else
        if [[ "$old_hash" != "$hash" ]]; then
            text=$(_status_modified "$file")
        fi
    fi
    [[ -n "$text" ]] && echo "$text"
}

_status_added() {
    local file=${1:?missing argument}
    local relative_file=$(_get_relative_store_path_from_pwd "$file")
    echo "new file: $relative_file"
}

_status_modified() {
    local file=${1:?missing argument}
    local relative_file=$(_get_relative_store_path_from_pwd "$file")
    echo "modified: $relative_file"
}

_status_deleted() {
    local file=${1:?missing argument}
    local relative_file=$(_get_relative_store_path_from_pwd "$file")
    echo "deleted:  $relative_file"
}

store_status() {
    local text=""
    local msgs=()
    if [[ -f "$STORE_INDEX" ]]; then
        while IFS='|' read action file hash; do
            case "$action" in
                A) text=$(_status_index_added "$file" $hash);;
                D) text=$(_status_deleted "$file");;
                *) text="";;
            esac
            [[ -n "$text" ]] && msgs+=("$text")
        done < <(egrep -v '^#' "$STORE_INDEX")
        if [[ "${#msgs[@]}" -gt 0 ]]; then
            echo "Changes to be committed:"
            echo "  (use \"$self reset <file>...\" to unstage)"
            for text in "${msgs[@]}"; do
                local color_text=$(say_color yellow "$text")
                printf "\t%s\n" "$(say_color yellow "$text")"
            done
            echo
        fi
    fi

    if [[ -f "$STORE_LOCAL_INDEX" ]]; then
        msgs=()
        while IFS='|' read hash file size; do
            local file_path=$(_get_abspath_from_rootdir "$file")
            local local_hash=$(git_store hash-object "$file_path" 2>/dev/null)
            local index_hash=$(_get_hash_from_store_index "$file")
            local index_action=$(_get_action_from_store_index "$file")
            # Delete case
            if [[ ! -f "$file_path" ]]; then
                [[ "$index_action" == D ]] && continue # Already mark as delete
                msgs+=("$(_status_deleted "$file")")
                continue
            fi
            if [[ "$local_hash" != "$hash" && "$local_hash" != "$index_hash" ]]; then
                msgs+=("$(_status_modified "$file")")
                continue
            fi
        done < <(egrep -v '^#' "$STORE_LOCAL_INDEX")
        if [[ "${#msgs[*]}" -gt 0 ]]; then

            echo 'Changes not staged for commit:'
            echo "  (use \"$self add <file>...\" to update what will be committed)"
            echo "  (use \"$self checkout <file>...\" to discard changes in working directory)"
            echo
            for text in "${msgs[@]}"; do
                printf "\t%s\n" "$(say_color green "$text")"
            done
            echo
        fi
    fi

    # Untracked files
    echo 'Untracked files:'
    echo "  (use \"$self add <file>...\" to include in what will be committed)"
    local file
    while IFS= read -r -u3 file; do
        printf "\t%s\n" "$(say_color cyan "$(_get_relative_store_path_from_pwd "$file")")"
    done 3< <(git_store status --untracked-files=normal --porcelain | sed -nr 's|^\?\?\s*(.+)$|\1|p')
}

store_push() {
    local tmp1=$(mktemp)

    _define_remote_store_name
    if [[ "$REMOTE_STORE_URL" =~ git://* ]]; then
        echo "Error: you must use a read/write URL to push on remote repository" >&2
        echo "Actually the remote URL is: $REMOTE_STORE_URL" >&2
        echo "Change it with command like:" >&2
        echo "git config remote.${REMOTE_STORE}.url USERNAME@HOST:/path/to/repository.git" >&2
        exit 1
    fi

    _fetch_remote_ref_all_files || exit $?

    git_store show $REFS_STORE/all_files -- | egrep -v '^#' > "$tmp1"
    cut -d'|' -f1-2 "$tmp1" | sort -u > "$tmp1".mini

    local tmp2=$(mktemp)
    while read -r link_hash file; do
        local object_file=$(git cat-file -p $link_hash)
        if [[ "$object_file" ==  *"$STORE_OBJECT_DIR_FROM_ROOT"/* ]]; then
            local hash="${object_file##*/}" # get hash from object name
            echo "${hash}|${file}" >> "$tmp2"
        fi
    done < <(cd "$ROOT_DIR" && git ls-files -s :/  | awk '/^120000/ { $1=$3=""; printf "%s\n",substr($0,2)}' )
    sort -u "$tmp2"> "$tmp2".mini

    local count=0

    # push new hashs
    while IFS='|' read hash file; do
        # echo "$hash -> $file"
        # check if the blob exists locally
        git_store cat-file -e $hash
        if [[ $? -eq 0 ]]; then
            printf "Pushing %s to %s...\n" "$(say_color cyan $file)" "$(say_color green $REMOTE_STORE)"
            git_store push -q "$REMOTE_STORE_URL" $hash:$REFS_STORE/$hash || exit $?
            local size=$(git_store cat-file -s $hash) || exit $?
            # Add timestamp
            echo "$hash|$file|$size|$(date '+%s')" >> "$tmp1"
            (( count++ ))
        fi
    done < <(comm -1 -3 "$tmp1".mini "$tmp2".mini | sort -t'|' -k2)
    rm -f "$tmp1".mini "$tmp2".mini

    sort -u -t'|' -k2 "$tmp1" > "$tmp2"

    local hash=$(git_store hash-object -t blob -w "$tmp2")
    rm -f "$tmp1" "$tmp2"

    if [[ $count -gt 0 ]]; then
        # Push the new all_files file
        git_store push --force -q "$REMOTE_STORE_URL" $hash:$REFS_STORE/all_files 2>/dev/null || exit $?
        git_store update-ref "$REFS_STORE/all_files" $hash || exit $?
    fi
}

store_cleanup() {
    # Simple cleanup by removing data directory
    rm -rf "$STORE_OBJECTS_DIR"

    local tmp1=$(mktemp)
    git_store for-each-ref --format='%(objectname) %(objecttype) %(refname)' | \
     sed -nr "s|^([A-Fa-f0-9]{40})\s+blob\s+$REFS_STORE/[A-Fa-f0-9]{40}$|\1|p" | sort -u > "$tmp1"

    local tmp2=$(mktemp)
    while read -r link_hash file; do
        local object_file=$(git cat-file -p $link_hash)
        if [[ "$ROOT_DIR/$object_file" == "$STORE_OBJECTS_DIR"/* ]]; then
            local hash="${object_file##*/}" # get hash from object name
            echo "$hash" >> "$tmp2"
        fi
    done < <(git ls-files -s ":/"  | awk '/^120000/ { $1=$3=""; printf "%s\n",substr($0,2)}' )

    sort -u "$tmp2" > "$tmp2".sort

    while read hash; do
        git_store update-ref -d "$REFS_STORE/$hash"
    done < <(comm -2 -3 "$tmp1" "$tmp2".sort)

    # Prune all unreachable objects from the object database
    git_store prune --expire now

    rm -f "$tmp1" "$tmp2" "$tmp2".sort
}

store_fix() {
    while read -r file; do
        # The file must exists and the link must be wrong
        if [[ -L "$file" && ! -f "$file" ]]; then
            local object_file=$(readlink "$file")
            if [[ "$object_file" == *"$STORE_OBJECT_DIR_FROM_ROOT"/* ]]; then
                local hash="${object_file##*/}" # get hash from object name
                local object="$STORE_OBJECTS_DIR/$hash"
                local dirname_file=$(_get_abspath_from_pwd "$file")
                dirname_file="${dirname_file%/*}"
                local object_file_relative_to_file=$(relpath "$STORE_OBJECTS_DIR/$hash" "$dirname_file")
                ln -sf "$object_file_relative_to_file" "$file" || exit $?
            fi
        fi
    done < <(git ls-files -c -o --exclude="${STORE_GIT_DIR_NAME}"/ ":/")
}

store_direct() {
    # First get all the files
    store_checkout ":/" || exit $?
    while read -r file; do
        # The file must exists and must be a link
        if [[ -L "$file" && -f "$file" ]]; then
            local object_file=$(readlink "$file")
            if [[ "$object_file" == *"$STORE_OBJECT_DIR_FROM_ROOT"/* ]]; then
                local hash="${object_file##*/}" # get hash from object name
                local object="$STORE_OBJECTS_DIR/$hash"
                local full=$(_get_abspath_from_pwd "$file")
                _store_store "$hash" "$full"
                rm -f "$full" || exit $?
                cp "$object" "$full" || exit $?
            fi
        fi
    done < <(git ls-files -c -o --exclude="${STORE_GIT_DIR_NAME}"/ ":/")
}

store_indirect() {
    if [[ -f "$STORE_LOCAL_INDEX" ]]; then
        while IFS='|' read hash file size; do
            local file_path=$(_get_abspath_from_rootdir "$file")
            local local_hash=$(git_store hash-object "$file_path" 2>/dev/null)
            local index_hash=$(_get_hash_from_store "$file")
            #local index_action=$(_get_action_from_store_index "$file")
            if [[ "$local_hash" == "$index_hash" ]]; then
                # Restore the link
                local dirname_file="${file_path%/*}"
                local object_file_relative_to_file=$(relpath "$STORE_OBJECTS_DIR/$local_hash" "$dirname_file")
                ln -sf "$object_file_relative_to_file" "$file_path" || exit $?
            fi
        done < <(egrep -v '^#' "$STORE_LOCAL_INDEX")
    fi
}

store_precommit() {
    # Check to not commit large binary files
    local empty_tree=4b825dc642cb6eb9a060e54bf8d69288fbee4904
    local bad_files=()
    local files_size=()

    while IFS= read file; do
        local attr_size=$(LC_ALL=C git check-attr store.max_size "$file" | sed 's/^.*: //')
        [[ "$attr_size" == 'none' ]] && continue
        if [[ "$attr_size" == 'unspecified' ]]; then
            max_size=1024000 # 1M
        else
            max_size=$(human_to_numeric "$attr_size")
            [[ $? -ne 0 ]] && die "Invalid size '$attr_size' in .gitattribute file !\n"
        fi
        local size=$(stat --printf="%s" "$ROOT_DIR/$file")
        if [[ "$size" -ge $max_size ]]; then
            local human_size=$(numeric_to_human "$size")
            # GIT_PREFIX is set by git when executing hook
            local relative_file=$(relpath "$ROOT_DIR/$file" "${GIT_PREFIX:-}")
            bad_files+=("$relative_file")
            files_size+=("$human_size")
        fi
    done < <(git diff --cached --numstat | grep -e '^-' | cut -f3)

    if [[ "${#bad_files[@]}" -gt 0 ]]; then
        error "trying to commit 'big' binary file(s):\n"
        local i
        for (( i=0; i< "${#bad_files[@]}"; i++ )); do
            printf "  %s\t%s\n" "${bad_files[$i]}" "${files_size[$i]}"
        done
        echo >&2
        echo "Export the file(s) to a git store repository with the git store command." >&2
        echo >&2
        echo "If you really want to always commit a large binary file (not recommended), add it" >&2
        echo "to the .gitattibutes file with the attribute store.max_size set to none like:" >&2
        echo "path_to_file/file store.max_size=none" >&2
        exit 1
    fi

    # Fix bad links
    store_fix
}

# Print the usage.
usage () {
    printf "Usage: %s ACTION [OPTION] [FILES]\n" "$self"
    echo   "Store/retrieve file(s) from a git repository";
    echo
    print_option_help "-h, --help" "print this message and exit"
    print_option_help "-v, --version" "print the version information and exit"
    echo
    printf   "* Add file(s):\n"
    print_option_help "$self add FILE(s)" "mark the FILE(s) to be added to the local $self repository"
    echo
    printf   "* Delete file(s):\n"
    print_option_help "$self rm FILE(s)" "mark the FILE(s) to be delete from the local $self repository"
    echo
    printf   "* Get file(s):\n"
    print_option_help "$self get [OPTIONS]  FILE(s)" "get FILE(s) from the local or remote $self repository"
    print_option_help "OPTIONS:"
    print_option_help "-d, --directory=DIR" "Checkout the file under the directoy DIR"
    print_option_help "-a, --all"           "Checkout all the files store in local $self repository"
    echo
    printf   "* Commit file(s):\n"
    print_option_help "$self commit FILE(s)" "commit the changes to the local $self repository"
    echo
    printf   "* Push file(s):\n"
    print_option_help "$self push" "push the local $self repository to the remote one"
    echo
    printf   "* Status file(s):\n"
    print_option_help "$self status" "Display the status of the files managed by the $self repository"
    echo
    printf   "* List files:\n"
    print_option_help "$self list [OPTIONS]" "list file(s)"
    print_option_help "OPTIONS:"
    print_option_help "--remote" "List ALL the files stored on the remote git repository"
    print_option_help "-r, --reverse-sorting"    "reverse order while sorting"
    print_option_help "-s, --sort-by-size"       "sort file(s) by size"
    print_option_help "-t, --sort-by-time"       "sort file(s) by date"
    echo
    printf   "* Direct/Indirect modes:\n"
    print_option_help "$self direct"   "Switches a repository to use direct mode, where rather than symlinks to files, the files are directly present in the repository."
    print_option_help "$self indirect" "Switches a repository back from direct mode to the default, indirect mode."
    echo
    printf   "* Maintenance:\n"
    print_option_help "$self fix" "fix bad link(s)"
    print_option_help "$self cleanup" "remove reference to store file(s)"
    echo
    echo "Report bugs to <leaf-devel@lists.sourceforge.net>."; echo
}

argument() {
    local opt=$1
    shift
    if [[ $# -eq 0 ]]; then
        printf "%s: option \`%s' requires an argument\n" "$0" "$opt" >&2
        exit 1
    fi
    echo $1
}

# Variables
declare -a ARGS=()
ACTION=""
OPT_REMOTE=0
OPT_A=0
OPT_R=0
OPT_S=0
OPT_T=0

# Check the arguments.
set -e # errexit
while [[ $# -gt 0 ]]; do
    option="$1"
    shift

    case "$option" in
        -h | --help)
                usage
                exit 0 ;;
        -v | --version)
                 echo "$self ${VERSION}"
                 exit 0 ;;
        -d | --directory)
                 CD=$(argument $option "$@"); shift;;
        --directory=*)
                 CD=${option#--directory=};;
        --remote)
                 OPT_REMOTE=1;;
        -a|--all)               OPT_A=1;;
        -r|--reverse-sorting)   OPT_R=1;;
        -s|--sort-by-size)      OPT_S=1;;
        -t|--sort-by-time)      OPT_T=1;;
        --debug) set -xv;;
        -*)
            printf "Unrecognized option \`%s'\n\n" "$option" >&2
            usage
            exit 1
            ;;
        *) ARGS+=("$option") ;; # $ fix fontification
    esac
done
set +e

ACTION="${ARGS[@]:0:1}";ARGS=( "${ARGS[@]:1}" )

ROOT_DIR=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ $? -ne 0 ]]; then
    echo "fatal: Not a git repository (or any of the parent directories)" >&2
    exit 128
fi

git_dir="$(readlink -f $(git rev-parse --git-dir))"
git_dir_basename=${git_dir##*/}
STORE_GIT_DIR="${STORE_GIT_DIR:-${ROOT_DIR}/.$self}"
if [[ ! -d "$STORE_GIT_DIR" ]]; then
    git_store init --quiet
    tmp=$(mktemp)
    mkdir -p "$git_dir/info"
    if [[ -f "$git_dir/info/exclude" ]]; then
        grep -v '^.git-store' "$git_dir/info/exclude" > "$tmp"
    fi
    echo '.git-store' >> "$tmp"
    mv "$tmp" "$git_dir/info/exclude"
fi
STORE_GIT_DIR_NAME="${STORE_GIT_DIR##*/}"
STORE_LOCAL_INDEX="${STORE_GIT_DIR}/.$self.local.idx"
STORE_INDEX="$STORE_GIT_DIR/store.idx"
declare -r STORE_OBJECTS_DIR="${STORE_GIT_DIR}/data"
[[ ! -d "$STORE_OBJECTS_DIR" ]] && mkdir -p "$STORE_OBJECTS_DIR"
declare -r STORE_OBJECT_DIR_FROM_ROOT="${STORE_GIT_DIR_NAME}/data"

precommit_hook_script="$git_dir/hooks/pre-commit"
if [[ ! -x "$precommit_hook_script" ]]; then
    mkdir -p "$git_dir/hooks"
    cat > "$precommit_hook_script" << EOF
#!/bin/bash
# automatically configured by $self
$self pre-commit .
EOF
    chmod 755 "$precommit_hook_script"
fi

set -u # Blow on unbound variable

case "$ACTION" in
    add) store_add "${ARGS[@]:-}";;
    delete|rm)   store_remove "${ARGS[@]:-}";;
    checkout|co|get) store_checkout "${ARGS[@]:-.}";;
    commit) store_commit;;
    list|ls) store_list;;
    status|st) store_status;;
    push) store_push;;
    fix) store_fix;;
    direct) store_direct;;
    indirect) store_indirect;;
    pre-commit) store_precommit;;
    cleanup) store_cleanup;;
    *) exit_code=0
       if [[ -z "$ACTION" ]]; then
           printf "You must specified an action !" >&2
       else
           if [[ "${GIT_STORE_DEVELOPER:-0}" -eq 1 ]]; then
               git_store "$ACTION" "${ARGS[@]:-}"
               exit $?
           fi
           printf "Invalid action '$ACTION' !" >&2
           exit_code=1
       fi
       printf "\n\n" >&2
       usage
       exit $exit_code;;
esac
