#!/bin/bash
#
# Created by Yves Blusseau for Bering uClibc
#
# This script is use to store/retrieve files store on a remote git repository
#
# Licensed under the Apace License 2.0
# http://www.apache.org/licenses/LICENSE-2.0.html
#

declare -r HEADER_STORE=$(cat <<EOF
#
# THIS FILE IS AUTOGENERATED! DO NOT MODIFY IT!
#
# Hash                                  | File       | Size
EOF
)

declare -r self="${0##*/}"
declare -r VERSION="1.0"
# Retrieve full path of the command
declare -r CMD=$(readlink -e "$0" || echo "$0")
# Retrieve full path of the library dir
declare -r LIBRARY_PATH=$(cd "${CMD%/*}" && echo "$PWD")

. "$LIBRARY_PATH"/utils.lib

declare -r REFS_STORE="refs/store"
declare -r EMPTY_BLOB_HASH='e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'

# Return the full path from pwd if $path is relative
# else it return $path
_get_abspath_from_pwd() {
    local path="${1:?missing argument}"
    echo $(abspath "$path" "$PWD")
}

# Return the full path from $root_dir if $path is relative
# else it return $path
_get_abspath_from_rootdir() {
    local path="${1:?missing argument}"
    echo $(abspath "$path" "$ROOT_DIR")
}

_get_relative_store_path_from_pwd() {
    local file="${1:?missing argument}"
    local full_path
    if [[ "$file" =~ ^/ ]]; then
        # Already absolute
        full_path="$file"
    else
        #It's relative
        full_path=$(_get_abspath_from_rootdir "$file")
    fi
    local relative_to_pwd=$(relpath "$full_path" "$PWD")
    echo "$relative_to_pwd"
}

_get_relative_store_path_from_rootdir() {
    local file="${1:?missing argument}"
    local full_path
    if [[ "$file" =~ ^/ ]]; then
        # Already absolute
        full_path="$file"
    else
        #It's relative
        full_path="$(_get_abspath_from_rootdir "$file")"
    fi
    echo "${full_path/$ROOT_DIR\//}"
}

_escape_ereg() {
    sed 's/[]\.|$(){}?+*^]/\\&/g' <<< "$@"
}

git_store() {
    git --git-dir="$STORE_GIT_DIR" $@
}

_define_remote_store_name() {
    [[ -n "${REMOTE_STORE_URL:-}" ]] && return 0
	#local git_store_configuration_file="$ROOT_DIR/.git-store.conf"
    #if [[ -f "$git_store_configuration_file" ]]; then
    #    local tracking_remote=$(git config --file "$git_store_configuration_file" remote.name)
    #    local remote_store_url="$(git_store config --get remote.${tracking_remote}.url)"
    #    if [[ -z "$remote_store_url" ]]; then
    #        git_store remote add "$tracking_remote" $(git config --file "$git_store_configuration_file" remote.url)
    #    fi
    #else
    # By default try to use the same remote that is used for the current branch
    local local_branch=$(git name-rev --name-only HEAD)
    # TODO check if we are not on detaching branch
    REMOTE_STORE=$(git config branch.${local_branch}.remote)
    [[ -z "$REMOTE_STORE" ]] && die "The current branch has no upstream defined !\n"
    REMOTE_STORE_URL=$(git config remote.${REMOTE_STORE}.url)
}

_update_store_file() {
    local file="${1:?missing argument}"
    local hash=${2:-}
    if [[ -f "$STORE" ]]; then
        local ereg="$(_escape_ereg "$file")"
        egrep -v "^#|[A-Fa-f0-9]{40}[|]${ereg}[|]" "$STORE" > "$STORE"~
    fi
    if [[ -n "$hash" ]]; then
        local size=$(git_store cat-file -s $hash) || exit $?
        echo "$hash|$file|$size" >> "$STORE"~
    fi
    echo "$HEADER_STORE" > "$STORE"
    cat "$STORE"~ | sort -u -t'|' -k2 >> "$STORE"
    rm -f "${STORE}"~
}

_update_gitignore_file() {
    return 0
    local tmp=$(mktemp)
    local header="# begin section managed by $self (do not edit this section by hand)"
    local footer="# end section managed by $self"
    [[ -f "$STORE" ]] && egrep -v '^#' "$STORE" | cut -d '|' -f2 > "$tmp"
    [[ -f "$STORE_INDEX" ]] && sed -nr 's|A[|]([^|]+)[|].*|\1|p' "$STORE_INDEX" >> "$tmp"
    sed -i "/$header/,/$footer/d" "$ROOT_DIR/.gitignore"
    echo "$header" >> "$ROOT_DIR/.gitignore"
    sort -u "$tmp" >> "$ROOT_DIR/.gitignore"
    echo "$footer" >> "$ROOT_DIR/.gitignore"
    rm -f "$tmp"
}

_get_hash_from_store() {
    search_file="${1:?missing argument}"
    if [[ -f "${STORE}" ]]; then
        local relfile=$(_get_relative_store_path_from_rootdir "$search_file")
        local ereg="$(_escape_ereg "$relfile")"
        sed -nr "s|([A-Fa-f0-9]{40})[|]$ereg[|].*|\1|p" "${STORE}"
    fi
}

_get_hash_from_store_index() {
    search_file="${1:?missing argument}"
    if [[ -f "${STORE_INDEX}" ]]; then
        local relfile=$(_get_relative_store_path_from_rootdir "$search_file")
        local ereg="$(_escape_ereg "$relfile")"
        sed -nr "s|^[AD][|]$ereg[|]([A-Fa-f0-9]{40}).*|\1|p" "${STORE_INDEX}"
    fi
}

_get_action_from_store_index() {
    search_file=${1:?missing argument}
    if [[ -f "${STORE_INDEX}" ]]; then
        local relfile=$(_get_relative_store_path_from_rootdir "$search_file")
        local ereg="$(_escape_ereg "$relfile")"
        sed -nr "s|^([AD])[|]$ereg[|].*|\1|p" "${STORE_INDEX}"
    fi
}

store_add() {
    for file in "$@"; do
        if [[ ! -e "$file" ]]; then
            echo "error: the file '$file' doesn't exist !" >&2
            continue
        fi
        if [[ -d "$file" ]]; then
            echo "error: can't add '$file' it's a directory" >&2
            continue
        fi

        local full=$(_get_abspath_from_pwd "$file")

        if [[ -L "$full" ]]; then
            # Short circuit if file is already in store
            [[ $(readlink -f "$full") == "$STORE_OBJECTS_DIR"/* ]] && return 0
            echo "error: can't add '$file' it's a link" >&2
            continue
        fi
        # Store the file
        local hash=$(git_store hash-object -t blob -w "$full") || exit $?
        local object="$STORE_OBJECTS_DIR/$hash"
        mv -f "$full" "$object" || exit 1
        chmod a-w "$object" || exit 1
        ln -sf $(relpath "$STORE_OBJECTS_DIR/$hash" "${full%/*}") "$full" || exit 1
        # Add the link
        git add "$file"
        local old_hash=$(_get_hash_from_store "$full")
        if [[ "$old_hash" != "$hash" ]]; then
            local relfile=$(_get_relative_store_path_from_rootdir "$full")
            if [[ -f "$STORE_INDEX" ]]; then
                local ereg="$(_escape_ereg "$file")"
                egrep -v "^[AD][|]${ereg}[|]" "$STORE_INDEX" > "$STORE_INDEX"~
            fi
            echo "A|$relfile|$hash" >> "$STORE_INDEX"~
            mv "$STORE_INDEX"~ "$STORE_INDEX"
        fi
    done
    _update_gitignore_file
}

store_remove() {
    for file in "$@"; do
        local full=$(_get_abspath_from_pwd "$file")
        local hash=""
        if [[ -f "$full" ]]; then
            # Store the file in case so we can restore it
            hash=$(git_store hash-object -t blob -w "$full") || exit $?
            rm -f "$full"
        fi
        local relfile=$(_get_relative_store_path_from_rootdir "$full")
        if [[ -f "$STORE_INDEX" ]]; then
            local ereg="$(_escape_ereg "$relfile")"
            egrep -v "^[AD][|]${ereg}[|]" "$STORE_INDEX" > "$STORE_INDEX"~
        fi
        echo "D|$relfile|$hash" >> "$STORE_INDEX"~
        mv "$STORE_INDEX"~ "$STORE_INDEX"
    done
    _update_gitignore_file
}

_store_store() {
    local hash=${1:?missing argument hash}
    local file=${2:?missing argument file}
    local relfile=$(_get_relative_store_path_from_rootdir "$file")
    _update_store_file "$relfile" "$hash" || exit $?
}

_store_remove_store() {
    local file=${1:?missing argument file}
    local relfile=$(_get_relative_store_path_from_rootdir "$file")
    _update_store_file "$relfile" || exit $?
}

_fetch_remote_ref() {
    local ref=${1:?missing argument ref}
    _define_remote_store_name
    # First check if the repository is correctly initialized and ref exists
    git_store ls-remote --exit-code $REMOTE_STORE_URL $REFS_STORE/$ref
    local exit_code=$?
    case "$exit_code" in
        0) ;;
        2) die "The reference doesn't exists on $REMOTE_STORE!\n" ;;
        *) die "Can't get remote reference !\nIs the $REMOTE_STORE repository initialized correctly ?\n"
    esac
    git_store fetch -q $REMOTE_STORE_URL $REFS_STORE/$ref:$REFS_STORE/$ref 2>&1
}

store_commit() {
    if [[ -f "$STORE_INDEX" ]]; then
        while IFS='|' read action file hash; do
            case "$action" in
                A) _store_store $hash "$file";;
                D) _store_remove_store "$file";;
            esac
        done < <(egrep -v '^#' "$STORE_INDEX")
    fi
    rm -f "$STORE_INDEX"

    # Add new local references
    while IFS='|' read hash file; do
        git_store cat-file -e $hash
        [[ $? -ne 0 ]] && continue
        git_store update-ref "$REFS_STORE/$hash" $hash || exit $?
    done < <(egrep -v '^#' "$STORE")

    # remove old local references
    while read hash ref; do
        # check if the ref exists in the store
        if [[ $(egrep -c "^$hash[|]" "$STORE") -eq 0 ]]; then
            git_store update-ref -d "$ref" || exit $?
        fi
    done < <(git_store for-each-ref --format='%(objectname) %(refname)' | egrep "\s$REFS_STORE/[A-Fa-f0-9]{40}")
    _update_gitignore_file
}

_do_checkout() {
    local full="${1:?missing argument file path}"
    if [[ ! "$full" =~ ^/ ]]; then
        echo "[_do_checkout] error: file path must be absolute !" >&2
        exit 1
    fi

    local object_file=$(readlink -f "$full")
    [[ "$object_file" != "$STORE_OBJECTS_DIR"/* ]] && exit 0
    local hash=${object_file/$STORE_OBJECTS_DIR\/}
    if [[ ! -f "$object_file" ]]; then
        # Check if the hash exists
        git_store cat-file -e $hash
        local hash_exist=$([[ $? -eq 0 ]] && echo 1 || echo 0)
        if [[ "$hash_exist" -eq 0 ]]; then
            # Try to download from remote
            _define_remote_store_name
            local relfile=$(_get_relative_store_path_from_rootdir "$full")
            printf "Downloading %s from %s...\n" "$(say_color cyan $relfile)" "$(say_color green $REMOTE_STORE)"
            _fetch_remote_ref "$hash"
        fi
        git_store update-ref "$REFS_STORE/$hash" $hash
        git_store show $hash -- > "$object_file" || exit 1
    fi
    chmod a-w "$object_file"
}

store_checkout() {
    local files_to_get=()
    for arg in "${@}"; do
        [[ "$arg" == ':/' ]] && arg="$ROOT_DIR"
        if [[ -d "$arg" ]]; then
            while read -r link_hash file; do
                local object_file=$(git cat-file -p $link_hash)
                if [[ "$ROOT_DIR/$object_file" == "$STORE_OBJECTS_DIR"/* ]]; then
                    files_to_get+=( "$file" )
                fi
            done < <(git ls-files -s "$arg"  | awk '/^120000/ { $1=$3=""; printf "%s\n",substr($0,2)}' )
        else
            files_to_get+=( "$arg" )
        fi
    done

    if [[ -n "${files_to_get[@]:-}" ]]; then
        for file in "${files_to_get[@]}"; do
            local full=$(_get_abspath_from_pwd "$file")
            _do_checkout "$full"
        done
    fi
}

store_reset() {
    local file
    for file in "$@"; do
        local full=$(_get_abspath_from_pwd "$file")
        local relfile=$(_get_relative_store_path_from_rootdir "$full")
        local ereg="$(_escape_ereg "$relfile")"
        sed -i -r "\|^[AD][|]$ereg[|].*|d" "${STORE_INDEX}"
    done
    _update_gitignore_file
}

store_list() {
    local cmd
    if [[ "$OPT_REMOTE" -eq 1 ]]; then
        _fetch_remote_ref 'all_files'
        cmd=("git_store" "show" "$REFS_STORE/all_files")
    else
        [[ ! -f "$STORE" ]] && touch "$STORE"
        cmd=("egrep" "-v" '^#' "$STORE")
    fi
    local now=$(date '+%s')
    local sort_opt=( -k 2 ) # sort by filename
    [[ "$OPT_S" -ne 0 ]] && sort_opt=( -n -k 3 ) # sort by size
    [[ "$OPT_T" -ne 0 ]] && sort_opt=( -n -k 4 ) # sort by date
    [[ "$OPT_R" -ne 0 ]] && sort_opt+=( -r ) # reverse sorting
    local tmp=$(mktemp)
    local total=0
    while IFS='|' read hash file size timestamp; do
        local date='     -     '
        if [[ -n "$timestamp" ]]; then
            local fmt='%b %d %R'
            # timestamp > 1 year
            [[ $(($now - $timestamp)) -gt 31536000 ]] && fmt="%b %d  %Y"
            date=$(date -d @$timestamp "+$fmt")
        fi
        total=$(( $total + $size ))
        printf "%s|%s|%s\n" $(numeric_to_human "$size") "$date" "$(_get_relative_store_path_from_pwd "$file")"
    done < <(${cmd[*]} | sort -t '|' ${sort_opt[@]}) >"$tmp"
    column -s '|' -t "$tmp"
    printf "Total: %s\n" $(numeric_to_human $total)
}

_status_index_added() {
    local file=${1:?missing argument}
    local hash=${2:?missing argument}
    local text
    local old_hash=$(_get_hash_from_store "$file")

    if [[ -z "$old_hash" ]]; then
        text=$(_status_added "$file")
    else
        if [[ "$old_hash" != "$hash" ]]; then
            text=$(_status_modified "$file")
        fi
    fi
    [[ -n "$text" ]] && echo "$text"
}

_status_added() {
    local file=${1:?missing argument}
    local relative_file=$(_get_relative_store_path_from_pwd "$file")
    echo "new file: $relative_file"
}

_status_modified() {
    local file=${1:?missing argument}
    local relative_file=$(_get_relative_store_path_from_pwd "$file")
    echo "modified: $relative_file"
}

_status_deleted() {
    local file=${1:?missing argument}
    local relative_file=$(_get_relative_store_path_from_pwd "$file")
    echo "deleted:  $relative_file"
}

store_status() {
    local text=""
    local msgs=()
    if [[ -f "$STORE_INDEX" ]]; then
        while IFS='|' read action file hash; do
            case "$action" in
                A) text=$(_status_index_added "$file" $hash);;
                D) text=$(_status_deleted "$file");;
                *) text="";;
            esac
            [[ -n "$text" ]] && msgs+=("$text")
        done < <(egrep -v '^#' "$STORE_INDEX")
        if [[ "${#msgs[@]}" -gt 0 ]]; then
            echo "Changes to be committed:"
            echo "  (use \"$self reset <file>...\" to unstage)"
            for text in "${msgs[@]}"; do
                local color_text=$(say_color yellow "$text")
                printf "\t%s\n" "$(say_color yellow "$text")"
            done
            echo
        fi
    fi

    if [[ -f "$STORE" ]]; then
        msgs=()
        while IFS='|' read hash file size; do
            local file_path=$(_get_abspath_from_rootdir "$file")
            local local_hash=$(git_store hash-object "$file_path" 2>/dev/null)
            local index_hash=$(_get_hash_from_store_index "$file")
            local index_action=$(_get_action_from_store_index "$file")
            # Delete case
            if [[ ! -f "$file_path" ]]; then
                [[ "$index_action" == D ]] && continue # Already mark as delete
                msgs+=("$(_status_deleted "$file")")
                continue
            fi
            if [[ "$local_hash" != "$hash" && "$local_hash" != "$index_hash" ]]; then
                msgs+=("$(_status_modified "$file")")
                continue
            fi
        done < <(egrep -v '^#' "$STORE")
        if [[ "${#msgs[*]}" -gt 0 ]]; then

            echo 'Changes not staged for commit:'
            echo "  (use \"$self add <file>...\" to update what will be committed)"
            echo "  (use \"$self checkout <file>...\" to discard changes in working directory)"
            echo
            for text in "${msgs[@]}"; do
                printf "\t%s\n" "$(say_color green "$text")"
            done
            echo
        fi
    fi

    # Untracked files
    echo 'Untracked files:'
    echo "  (use \"$self add <file>...\" to include in what will be committed)"
    local file
    while IFS= read -r -u3 file; do
        printf "\t%s\n" "$(say_color cyan "$(_get_relative_store_path_from_pwd "$file")")"
    done 3< <(git_store status --untracked-files=normal --porcelain | sed -nr 's|^\?\?\s*(.+)$|\1|p')
}

store_push() {
    local tmp1=$(mktemp)

    _define_remote_store_name
    if [[ "$REMOTE_STORE_URL" =~ git://* ]]; then
        echo "Error: you must use a read/write URL to push on remote repository" >&2
        echo "Actually the remote URL is: $REMOTE_STORE_URL" >&2
        echo "Change it with command like:" >&2
        echo "git config remote.${REMOTE_STORE}.url USERNAME@HOST:/path/to/repository.git" >&2
        exit 1
    fi
    _fetch_remote_ref 'all_files'

    git_store show $REFS_STORE/all_files -- | egrep -v '^#' > "$tmp1"
    cut -d'|' -f1-2 "$tmp1" | sort -u > "$tmp1".mini

    local tmp2=$(mktemp)
    while read -r link_hash file; do
         local object_file=$(git cat-file -p $link_hash)
         if [[ "$ROOT_DIR/$object_file" == "$STORE_OBJECTS_DIR"/* ]]; then
             local hash="${object_file##*/}" # get hash from object name
             echo "${hash}|${file}" >> "$tmp2"
         fi
    done < <(git ls-files -s :/  | awk '/^120000/ { $1=$3=""; printf "%s\n",substr($0,2)}' )
    sort -u "$tmp2"> "$tmp2".mini

    local count=0

    # push new hashs
    while IFS='|' read hash file; do
        echo "$hash -> $file"
        # check if the blob exists locally
        git_store cat-file -e $hash
        if [[ $? -eq 0 ]]; then
            printf "Pushing %s to %s...\n" "$(say_color cyan $file)" "$(say_color green $REMOTE_STORE)"
            git_store push -q "$REMOTE_STORE_URL" $hash:$REFS_STORE/$hash || exit $?
            local size=$(git_store cat-file -s $hash) || exit $?
            # Add timestamp
            echo "$hash|$file|$size|$(date '+%s')" >> "$tmp1"
            (( count++ ))
        fi
    done < <(comm -1 -3 "$tmp1".mini "$tmp2".mini | sort -t'|' -k2)
    rm -f "$tmp1".mini "$tmp2".mini

    sort -u -t'|' -k2 "$tmp1" > "$tmp2"

    local hash=$(git_store hash-object -t blob -w "$tmp2")
    rm -f "$tmp1" "$tmp2"

    if [[ $count -gt 0 ]]; then
        # Push the new all_files file
        git_store push --force -q "$REMOTE_STORE_URL" $hash:$REFS_STORE/all_files 2>/dev/null || exit $?
        git_store update-ref "$REFS_STORE/all_files" $hash || exit $?
    fi
}

store_cleanup() {
    local tmp1=$(mktemp)

    git_store for-each-ref --format='%(objectname) %(objecttype) %(refname)' | \
        sed -nr "s|^([A-Fa-f0-9]{40})\s+blob\s+$REFS_STORE/[A-Fa-f0-9]{40}$|\1|p" | sort -u >"$tmp1"

    local tmp2=$(mktemp)
    [[ -f "${STORE}" ]] && sed -nr "s|^([A-Fa-f0-9]{40})[|].*|\1|p" "${STORE}" | sort -u >"$tmp2"

    local hash
    while read hash; do
        git_store update-ref -d "$REFS_STORE/$hash"
    done < <(comm -2 -3 "$tmp1" "$tmp2")

    [[ -f "${STORE}" ]] && sed -nr "s|^([A-Fa-f0-9]{40}[|][^|]+[|]).*|\1|p" "${STORE}" >"$tmp1"
    git_store show $REFS_STORE/all_files 2>/dev/null | sed -nr "s|^([A-Fa-f0-9]{40}[|][^|]+[|]).*|\1|p" >"$tmp2"
    local file
    while read file; do
        local full="$(_get_abspath_from_rootdir "$file")"
        [[ ! -f "$full" ]] && continue
        local local_hash=$(git_store hash-object "$full")
        local ereg="$(_escape_ereg "$file")"
        [[ $(egrep -c "^$local_hash[|]$ereg[|]" "$tmp1") -ne 0 ]] && continue
        [[ $(egrep -c "^$local_hash[|]$ereg[|]" "$tmp2") -ne 0 ]] && rm -f "$full"
    done < <( cut -d'|' -f2 "$tmp1" "$tmp2" | sort -u)

    rm -f "$tmp1" "$tmp2"
}


# Print the usage.
usage () {
    printf "Usage: %s ACTION [OPTION] [FILES]\n" "$self"
    echo   "Store/retrieve file(s) from a git repository";
    echo
    print_option_help "-h, --help" "print this message and exit"
    print_option_help "-v, --version" "print the version information and exit"
    echo
    printf   "* Add file(s):\n"
    print_option_help "$self add FILE(s)" "mark the FILE(s) to be added to the local $self repository"
    echo
    printf   "* Delete file(s):\n"
    print_option_help "$self rm FILE(s)" "mark the FILE(s) to be delete from the local $self repository"
    echo
    printf   "* Get file(s):\n"
    print_option_help "$self get [OPTIONS]  FILE(s)" "get FILE(s) from the local or remote $self repository"
    print_option_help "OPTIONS:"
    print_option_help "-d, --directory=DIR" "Checkout the file under the directoy DIR"
    print_option_help "-a, --all"           "Checkout all the files store in local $self repository"
    echo
    printf   "* Reset file(s):\n"
    print_option_help "$self reset FILE(s)" "reset changes to be commit"
    echo
    printf   "* Commit file(s):\n"
    print_option_help "$self commit FILE(s)" "commit the changes to the local $self repository"
    echo
    printf   "* Push file(s):\n"
    print_option_help "$self push" "push the local $self repository to the remote one"
    echo
    printf   "* Status file(s):\n"
    print_option_help "$self status" "Display the status of the files managed by the $self repository"
    echo
    printf   "* List files:\n"
    print_option_help "$self list [OPTIONS]" "list file(s)"
    print_option_help "OPTIONS:"
    print_option_help "--remote" "List ALL the files stored on the remote git repository"
    print_option_help "-r, --reverse-sorting"    "reverse order while sorting"
    print_option_help "-s, --sort-by-size"       "sort file(s) by size"
    print_option_help "-t, --sort-by-time"       "sort file(s) by date"
    echo
    printf   "* Cleanup the $self repository:\n"
    print_option_help "$self cleanup" "remove reference to store file(s)"
    echo
    echo "Report bugs to <leaf-devel@lists.sourceforge.net>."; echo
}

argument() {
    local opt=$1
    shift
    if [[ $# -eq 0 ]]; then
        printf "%s: option \`%s' requires an argument\n" "$0" "$opt" >&2
        exit 1
    fi
    echo $1
}

# Variables
declare -a ARGS=()
ACTION=""
OPT_REMOTE=0
OPT_A=0
OPT_R=0
OPT_S=0
OPT_T=0

# Check the arguments.
set -e # errexit
while [[ $# -gt 0 ]]; do
    option="$1"
    shift

    case "$option" in
        -h | --help)
                usage
                exit 0 ;;
        -v | --version)
                 echo "$self ${VERSION}"
                 exit 0 ;;
        -d | --directory)
                 CD=$(argument $option "$@"); shift;;
        --directory=*)
                 CD=${option#--directory=};;
        --remote)
                 OPT_REMOTE=1;;
        -a|--all)               OPT_A=1;;
        -r|--reverse-sorting)   OPT_R=1;;
        -s|--sort-by-size)      OPT_S=1;;
        -t|--sort-by-time)      OPT_T=1;;
        --debug) set -xv;;
        -*)
            printf "Unrecognized option \`%s'\n\n" "$option" >&2
            usage
            exit 1
            ;;
        *) ARGS+=("$option") ;; # $ fix fontification
    esac
done
set +e

ACTION="${ARGS[@]:0:1}";ARGS=( "${ARGS[@]:1}" )

ROOT_DIR=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ $? -ne 0 ]]; then
    echo "fatal: Not a git repository (or any of the parent directories)" >&2
    exit 128
fi
STORE="$ROOT_DIR/.$self.idx"
STORE_GIT_DIR=$(_get_abspath_from_pwd "$ROOT_DIR/.${self}")
STORE_INDEX="$STORE_GIT_DIR/store.idx"
declare -r STORE_OBJECTS_DIR="${STORE_GIT_DIR}/objects"
[[ ! -d "$STORE_OBJECTS_DIR" ]] && git_store init --quiet

set -u # Blow on unbound variable

case "$ACTION" in
    add) store_add "${ARGS[@]:-}";;
    delete|rm)   store_remove "${ARGS[@]:-}";;
    checkout|co|get) store_checkout "${ARGS[@]:-.}";;
    reset) store_reset "${ARGS[@]:-}";;
    commit) store_commit;;
    list|ls) store_list;;
    status|st) store_status;;
    push) store_push;;
    cleanup) store_cleanup;;
    *) if [[ -z "$ACTION" ]]; then
           printf "You must specified an action !" >&2
       else
           printf "Invalid action '$ACTION' !" >&2
       fi
       printf "\n\n" >&2
       usage;;
esac
